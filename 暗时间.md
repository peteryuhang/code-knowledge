## 如何有效地记忆与学习

- 我们记忆的时候将许多线索（例如当时的场景、问题的背景，甚至所处的语言环境、空间位置）一并编码进了记忆，事后能否提取出这段记忆严重取决于提取线索是否丰富，以及在回忆时是否重现了记忆时的线索
- 一些辅助记忆的良好习惯：
  - 经常与别人讨论，或者是讲给别人听
  - 整理笔记
  - 书写
  - 设身处地 “虚拟经历” 别人经历过的事情
  - 抽象和推广
  - 联系/比较自身的经历
    - 样本大小很关键
    - 警惕 “沉默的证据”、事后偏见、自利归因
- 如果你想真正得到一些知识，最好过滤一下你的信息，否则你只是在别人的思考中得意着

例子：
- 非洲鱼：一种鱼干不过鱼 B，当它看到鱼 B 干不过鱼 C，自己就会躲着鱼 C 远远的

## 学习密度与专注力

- 培养专注力的习惯
  - 做自己喜欢做的事
  - 享受困难
  - 不主动关注哪些自己觉得没有价值的事

## 学习习惯

### 学习与思考

- Google&Wiki
- 看书挑剔，只看经典
- 做读书笔记
  - 将自己阅读时候的思考（包括闪念）总结下来
  - 将书中的好例子摘抄下来
  - 很多时候，仅仅是用自己的语言重新表述一下就能极大地加深印象和理解
- 放一个问题在脑子里，利用闲暇以及睡觉的时间去思考
  - 将思考变成习惯可以避免焦虑——投入地做另一件事可以避免自己对某件事情的焦虑
- 多看心理学与思维的书，因为它们是跨学科的
- 学习一项知识，必须问自己三个重要的问题：
  1. 它的本质是什么
  2. 它的第一原则是什么
  3. 它的知识结构是怎样的
- 学习和思考的过程中常问自己的几个问题
  1. 你的问题到底是什么？——提醒自己思考不要偏离问题
  2. OK，到现在为止，我到底有什么收获？——提醒自己时不时总结，整理学过的东西
  3. 设想自己正在将东西讲给别人听——能否讲出来是判断是否真正理解的最佳方法
  4. 设想需要讲给一个不懂的人听——迫使自己去挖掘知识背后最本质、往往也是最简单的解释
  5. 时常反省和注意自己的思维过程，尤其是当遇到无法理解或解决的问题后，将思维的大致脉络写下来是一个很好的习惯
  6. 养成反驳自己想法的习惯
  7. 人的思维天生就是极易流于表面来理解事物的。觉得自己理解了一个问题吗？条件反射性地问自己：
    - 你真的理解吗？
    - 你真的理解了问题的本质了？
    - 问题的本质到底是什么？
    - 目前我的理解是什么？
    - 这样的理解到底有什么建设性？
    - 。。。

### 时间和效率

- 趁着对一件事情有热情的时候，一股脑把万事开头那个最难的阶段熬过去
- 重要的事优先
- 重要的事情要营造比较大的时间块来完成
- 同时也要善于利用小块时间
- 重视知识的本质
- 重视提前积累的强大力量
- 抬起头来
- 有时间吗？总结总结最近得到的新知识
- 有时间吗？看本书吧
- 制定简要的阅读计划

#### 读书

- 根据主题来查阅资料，而不是根据资料来查阅主题
- 好资料的特点：
  - 从问题出发
  - 重点介绍方法背后的理念，注重直观解释，而不是方法的技术细节
  - 按照方法被发明的时间流程来介绍（当前方法是如何通过之前的方法一步步的改进得到的）
- 学习一个东西之前，首先在大脑中积累充分的 “疑惑感”
  - 你对问题的疑惑越大，在之前思考的越多，当看到解答后印象就会越深刻
- 有选择地阅读
  - 选择一本书中感兴趣的章节优先阅读
  - 对一本书中技术性较弱或信息密度较低的部分快速地略读
- 在阅读的时候可以用下面三个问题切分内容：
  1. 问题是什么？
  2. 方案是什么？
  3. 例子是什么？
- 或者是解释现象的：
  1. 现象是什么？
  2. 解释是什么？
  3. 支撑这个解释的理由是什么？
  4. 例子是什么？
- 阅读的分类：
  - 知识类
  - 思维类
- 利用时间碎片：任何一点时间都可以用于阅读
- 看不懂一个知识的原因：
  - 看得不够使劲
  - 其中涉及到了你不懂的概念
  - 作者讲述的顺序不对
- 如何在阅读之前就能获得对一本书质量的大致评估
  - 看作者
  - 看目录和简介
  - 看评价
  - 看样章
- 如何搜寻到好书
  - 同作者的著作
  - 一本好的著作在参考资料里面重点提到的其他著作
  - 对于一个主题，搜索到好心人总结的参考资源导引

### 知识结构

- 抓住不变量
  - （不变量）本质知识：深入掌握牢靠
  - 非本质知识：待用到的时刻 RTM（Read The Manual）
- 学会在纷繁的知识中抽象出那些重要的、本质的、不变的东西
- 本质的知识：
  - 分析问题和解决问题的思维方法
  - 判断与决策的方法

## 思维改变生活

- 用数学的语言来说，自然选择过程试图最优化的目标函数并不是 “幸福感”，而是 “繁衍概率”
- 没有得到好的结果并不代表你的过程就错了，结果正确也不代表方法就一定正确
  - 看重过程而非单次的结果，再好的过程也可能会偶尔失利，但从长远来统计，好的过程总体上必然导致更好的结果
- 普通人从自己的错误中学习，聪明人从别人的错误中学习
- 尽量去让我们大脑中假想的角色去经历虚拟的失败，从而避免在现实中去碰一鼻子灰
  - 我们在大脑中走的越远，在现实中就走的越稳，在大脑中失败的次数越多，在现实中失败的次数就越少

- 我们的大脑从外界接受到的信息其实是满含着歧义的，然而我们的大脑几乎每次都能够从富含歧义的信息中找出最靠谱的解释
  - 这得益于漫长的进化过程，以及我们平常生活中积累的大量先验假设
  - 这些先验假设是双刃剑

- 打破偏见的唯一途径就是开阔视野，多积累知识，以及和具有不同知识背景的人讨论，否则就算是抱着 “我可能是错的” 这种信念，你也不知道怎么去证伪自己的一个猜测
- 时常使用以下两句话来提醒自己保持 Open Mind：
  - 这只是一种可能，未必是唯一的可能
  - 想不出其他解释不代表就不存在其他解释

- 事实上，我们所谓的生活的意义来源于情感系统（情绪脑）
- 很多时候我们只是生活在信息社会的远古人
  - 分不清什么是虚拟什么是真实

- 通过提供不断的进展，让执行者意识到事情正在朝向完成不断迈进，这种正面趋势所带来的积极情感能够进一步激励个体把事情执行到底（例子：将手放在冰水中。。。）

- 我们的理性大脑非常善于对自己的行为作出立即的、看上去合理的解释
- 我们知道答案，却往往不知道求解的真正思维过程
  - 我们的意识就像是一个等着老师给出答案的小学生，只能眼巴巴地在那等着，至于老师是怎么想出答案的，老师不告诉你
  - 只要我们的情绪大脑首先认定了一件事情，我们那点可怜的理性思维便很容易屈从于情绪大脑发下的命令——把事情往利于自己的方向解释
  - 只要一种解释是对自己有利的，我们便不想去推敲和反驳，再漏洞百出的事情看上去也不无可能，而且只要一种解释是有可能的，我们就认定其一定是的
  - 而对自己不利的解释，我们或者忽略，或者则会异常仔细地去推敲，抓住一个细小漏洞则相信已完全推翻了该解释（尤其是当为一件事付出了金钱、社会关系，很多很多之后）
  - 我们每个人大脑中都有思想钢印。这道钢印由经验打造，用自尊来维护，牢不可破，比钻石的硬度还高

- 客观意味着承认存在未知信息的可能性，理性意味着能够从对立面的视角去看问题和思考
- 学会质疑自己的判断，假设自己是站在对立面的立场上帮他说话，往往能够发现很多意料之外的东西；即便别人是错的，尝试着理解别人为什么错
- 与其让别人指出自己的错误，不如自己试着去发现自己的错误

- **习惯之所以难以改变，就是因为习惯是自我巩固的 —— 越用越强，越强越用**
  - 如果你总是情绪用事，不假思索，那么这种思维习惯便会越来越强大
  - 如果你总是理性思考，反省自己的判断，能换立场去看问题，那么这样的思维习惯逐渐也会越来越强大

### 书写是为了更好的思考

- 书写是对思维的备忘
- 书写是对思维的缓存（工作记忆有限，仅靠大脑思维总是走不远）
- 书写是与自己的对话（如果不用纸笔，仅用大脑，很难在思考一个问题的同时对自己的思考进行反思）
- 书写是与别人的交流（如果你不知道一个东西，很大的可能性你也不知道你自己不知道它）
- 有时候，语言自己也会思考

### 写博客的好处

- 能够交到很多志同道合的朋友
- 书写是为了更好地思考
- “教” 是最好的 “学”（如果一件事情你不能讲清楚，十有八九你还没有完全理解）
- 讨论是绝佳的反思
- 激励你去持续学习和思考
- 学会持之以恒地做一件事情
- 一个长期的价值博客是一份很好的简历

### 我不想与我不能

- **自利归因**：把一件事情的发生的原因归结为对自己有利的那种情况
- 我们的努力是为了增大结果发生的几率，而不是为了那个确定的结果
- 别给自己找理由，因为那等同于说 “我不能___，我没有___”，等于否定自己的主观能动性
- 凡事多往自身归因，你才能披荆斩棘

### 遇到问题为什么要自己动手

- 相比于体力活，对学习新知识的困难程度的评估，我们却很不在行，因为大部分知识都是需要等你掌握了之后才会 “豁然开朗”、“柳暗花明” 的
- **“Unknown Unknown”**：如果你不知道一个东西，你也不会知道自己不知道它（新知识的特性，感觉到困难的根本原因）
- **寻找捷径只是小聪明**：我们计算收益的时候仅仅考虑是否解决了手头的问题，而解决的过程中其实还会获得许多其他的收益
- 生活或工作中，很大程度上你遇到的每个问题都不是孤立的，既然你遇到了某问题，那么很大可能性你以后还会遇到类似的问题
- **困难的路越走越容易，容易的路越走越困难**

### 什么才是你的不可替代性和核心竞争力

- 个人的核心竞争力是他独特的个性知识经验组合，如果这种组合具备以下 3 点，那么你就具备核心竞争力
  1. 绝无仅有
  2. 在实践中有价值
  3. 具有可持续发展性

- **应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越**

- 以下知识技能组合是具有相当程度的不可替代性：
  1. 专业领域技能
  2. 跨领域的技能（解决问题的能力、创新思维、判断与决策的能力、批判性思维、表达沟通能力）
  3. 学习能力（持续学习和思考新知识）
  4. 性格要素（专注、持之以恒、自省、好奇心、自信、谦卑）

## 跟波利亚学解题

- 人类整个认知系统中有大量功能从本质上都是硬编码（因而才有人人都概莫能外的各种认知偏见）
- 越是高等的动物，大脑中用于处理特定问题的硬编码神经元回路就越是多和复杂
- 所有的启发式思维方法（heuristics）实质上都是为了联想服务的，而联想则是为了从我们的大脑的知识系统中提取出有价值的性质或定理，从而补上从条件到结论、从已知到未知之间缺失的链环

- Working Backwards（倒过来解）:
  - 首先我们把需要求解的问题本身当成条件，从它推导出结论，再从这个结论推导出更多的结论，直到某一个点上我们发现已经出现了真正已知的条件。这个过程称为分析。有了这条路径，我们便可以从已知条件出发，一路推导到问题的解
- 欧拉认为如果不能把解决数学问题背后的思维过程交给学生的话，数学教学就是没有意义的
- **启发式思考方法**：
  - 时刻不忘未知量（时刻别忘记你到底想要求什么，问题是什么）
  - 用特例启发思考（一个泛化的问题往往有一种 “不确定性”，这种不确定性会成为思维的障碍）
  - 反过来推导（反向解题隐含了解题中至为深刻的思想：**归约**）
    - 倒推法之所以是一种极为深刻的思维方法，本质上是因为它充分利用了题目中一个最不易被觉察到的信息 —— 结论。
    - 结论往往蕴含着丰富的条件，譬如对什么样的解才是满足题意的解的约束。一般来说，借助结论中蕴含的知识，我们便可以更为 “智能地” 搜索解空间
    - 笛卡尔的万能解题法：将问题转化为代数问题，然后设未知数，解方程组，这本质上就是一种倒推：假想结论 `x`，将题目对 `x` 的需求表达出来，然后顺势而下推导出 `x`
  - 试错
  - 调整题目的条件（如，删除、增加、改变条件）
    - 通过调整题目条件，我们能够发现条件和结论之间是如何联系的
  - 求解一个类似的题目
    - 为了便于脑中的知识结构真正能够 “迁移”，在记忆掌握和分析问题的时候都应该尽量抽象地去看待，这样才能够建立知识的本质联系，才能够最大化联想空间
  - 列出所有可能跟问题有关的定理或性质
  - 考察反面，考察所有情况（避免陷入特定的解题手法）
  - 将问题泛化，并求解这个泛化后的问题
  - **意识孵化法**（我们先把问题吃透，放在脑子里，等着我们的下意识把它解出来）
  - 烫手山芋法（把问题扔给别人解决，网络赋予了这个方法优越性）
- 充分挖掘题目中蕴含的知识，是解题的最关键步骤，本质上，所有的启发式方法某种意义上都是为此服务的，譬如，联想、演绎和归纳

- 事实上，不需要借助于认知科学，单单是通过对我们自己的思维过程的自我观察，也许就已经能够总结出一些重要的规律了，也许，对思维过程的反观真的是人有别于其他动物的本质区别
- 知识是一把双刃剑，一方面，它们提供给了我们解决问题无以伦比的捷径优势，“砖头是砌墙的”，于是我们遇到砌墙这个问题就可以迅速利用砖头。然而另一方面，知识却也是思维的桎梏
  - 思维定势就是指下意识遵循既有知识框架思考的过程
  - 如何在获取知识优势的同时，防止被知识束缚住，是一门技术。掌握这门技术的钥匙，就是 **抽象**
  - 再吸收知识的时候进行抽象，同时在面对需要用到知识的新问题时也要对问题进行抽象
- 抽象是对非本质细节去枝减叶的过程，是我们在掌握知识和解决问题时候的一把有力的奥卡姆剃刀
  - 无论是在解题还是在学习的过程中，问自己一个问题 **“我是不是已经掌握了这个知识最深刻最本质的东西”**

- 好题目，即测试一个人思维的习惯的题目，有以下一些性质：
  - 不需要用到未知的知识
  - 需要用到未知的知识，但一个敏锐的解题者可以通过对题目的分析自行发现这些所需的知识
  - 考察解题的一般性思路，而不是特定（ad hoc）的解题技巧
  - 考察思维能力。联想能力、类比能力、抽象能力、演绎能力、归纳能力、观察能力、发散能力（思维不落巢臼的能力）
  - 考察一般性思维方法。
    - 通过特例启发思考
    - 通过试错寻找规律
    - 通过泛化试探更一般性命题
    - 通过倒过来推导将问题进行归约
    - 通过调整（分解、删除、增加，等等）题目条件来感知它们之间的联系以及和结论的联系
    - 通过系统化的分类讨论来覆盖每种可能性
  - 好题目例举：
    - 烙饼排序问题
    - Nim 问题
    - 9 公升 4 公升水桶倒 6 公升水的问题
    - 9 点连线问题
    - 6 根火柴搭出 4 个面的问题
    - “木板” 问题
    - 许多数论问题

- 在思考一个问题的时候，最容易犯的一类错误是忘了考虑某种可能性，不管这种可能性是另一种做法
  - 一个有效的办法就是将自己的思考过程清晰地写在纸上
- 练习并不产生新能力，然而练习会将平时需要用脑子去想（参与）的东西转化为内在的习惯
- **解题练习的最重要目的不是将特定的题目解出来，而是在于反思解题过程中的一般性、跨问题的思维法则**
  - 简单地将题目解出来，或者解不出来直接看答案只能算是理解，而理解和应用还差十万八千里，要运用的话需要自己去想出那关键的一步
  - 需要去揣测和总结别人的思维是如何触及那关键的一步，而你自己的思维又为什么触及不到它，有没有一般性的原则可以指导你下次也能想到那个 “关键的一步”？

### 锤子和钉子

- 心中有锤，就容易为其奴役，始终莫要忘记提醒自己 —— **“问题是什么？”**
- 正确的态度是 —— **手中有锤，心中无锤**
- Why 永远在 How 之前

- 对应的一句话：如果你想钉一个钉子，所有东西看上去都像是锤子
  - **如果你心中专注于你想要解决的问题，那么你所看到的东西就会呈现出以往你没有看到的一面**

- 把自己变成钉子，这就是 Eureka 的奥秘

### 鱼是最后一个看到水的

- 人倾向于在既有框架下去解决问题；更重要的是，在这个过程中很难觉察到框架约束的存在
- 在这一切背后的本质原因是：**人是有很强的适应性的**
- 普通人遵守规则，牛人无视规则，伟人创造规则
- 在既有框架下解决问题很多人都会，难就难在意识到框架的存在并突破它
- 把简单的事情搞复杂的人比比皆是，把复杂的事情的人凤毛麟角
- 编程语言之争的原因之一就是人们容易在自己熟悉的语言框架下思考，并形成严重的偏见，只看到自己语言的好处，甚至于将并非好处的地方也觉知为好处
- 避免思维被一门语言束缚的最好办法就是 “学习其他语言”
- 学习编程重在学习基本的概念和素养，这些是长期稳定不变的东西，投入精力学习细节，学得越细，就越是容易淘汰
  - 一旦掌握了基本的概念，要用到细节的时候，细节自然会各就各位
- 脱离语言思考，使用语言实现

### 知其所以然

- 目前几乎所有的算法书的讲解方式都是欧几里得式的、瀑布式的、自上而下的，这完全把人类大脑创造发明的步骤给反过来了
- 我们要的不是相对论，而是诞生相对论的那个大脑。我们要的不是金蛋，而是下金蛋的那只鸡
- 我们在思考一个问题的过程中有两种思维形式：
  - **联想**：
    - 这个过程是试探性的
    - 联想本身需要记忆提取的线索，所以受到记忆提取线索的制约，如果线索不足，那怎么也联想不起来
  - **演绎 & 归纳**：
    - 对问题的各个条件进行演绎的推理过程
    - 通过对一些特殊形式的观察来进行归纳，试图总结问题中的规律
- 如果说问题求解是一部侦探小说，那么算法只是结局而已，而思考过程才是情节

- 讲述思维过程而非结果有几个极其重要的价值：
  1. 内隐化
    - 思维法则其实也是知识；是内隐的知识（元知识）
    - 要将思维方法内隐化，需要不断练习，就像需要不断练习才可在无意识状态下就能骑自行车一样
  2. 跨情景运用
    - 你学会了在解决数学问题的时候 “注意未知数” 却不一定能在解决现实生活中的问题中时刻都能 “注意你的未知数”（解决数学问题和解决生活中问题的场景不一样，不同的环境线索，在你大脑中激发的记忆也不一样）
  3. 对问题解的更多记忆提取线索
    - 比如知道算法是怎样一步步被推导出来的，我们就一下拥有了大量的记忆提取线索：对算法发现过程中的任何一个关键步骤（尤其是本质）的回忆都可能使我们能够自己动手推导出剩余的内容
  4. 包含了多得多的知识
    - 一个问题背后的思想，有助于解决一类问题
    - 算法诞生过程中的思路往往包含了比实际算法更本质得多的知识
  5. 重在分析推理，而不是联想
    - 重在思维的传授可以让人养成从问题本质入手，逐步分析推理的习惯，而不是直接生搬硬套
    - 很多时候我们并不知道问题的本质是什么，就需要靠联想、类比来领路探索
  
- 从一个算法中领悟尽量深刻的东西，则需要做到三件事情：
  1. 寻找该算法的原始出处
  2. 原始的出处其实也未必就都推心置腹地和你讲得那么到位
    - 算法设计出来了之后人们几乎是不会去回顾整个思维过程的细节，只把直指目标的那些东西写出来
  3. 不仅学习别人的思路，整理自己的思路也是极其重要的

- 写论文应该写得像侦探小说一样

### 为什么有必要知其所以然

- 没有明白背后的证明之前，任何一个定理对你来说都是等价的 —— 等价于背乘法口诀
- 去理解一个定理的证明会带来巨大的好处，第一个好处就是你很难再忘掉它：
  - 在没有理解一个定理的证明之前，定理对你而言是一堆没有内在联系的词句
  - 在理解了一个定理的证明之后，定理就归约为证明它所需要的条件加上逻辑，逻辑本来就存在于你的大脑里
  - 需要你去记忆的也只有一个或两个关键的 insights
- **这是一个树状的知识结构，越往上层走，需要记忆的节点就越少**
- 所谓触类旁通者，其实便是因为他擅长去理解解法背后的更具一般性的东西
- 一个好习惯，看到美妙的证明和解法总是会去一遍又一遍地反复揣摩，试图理解想出这个证明的人到底是怎么想出来的，有没有什么一般性的方法可循（在这样的揣摩中你会理解更深刻的东西，让你有举一反三的能力）
- 与看定理必看证明类似，看一个问题的解法，必然要看解法所诞生的过程，背后是否隐藏着更具一般性的解决问题的思路和原则
- 对于每个问题都能真正弄清以下这几个问题的答案，那么可以肯定的是，你的理解、记忆，以及学习的效率都会得到质的提高：
  - **为什么这种解法是对的？**
  - **为什么那种解法是错的？**
  - **为什么这种解法不是最优的？**
  - **证明为什么没有更优的解法**
- **知道怎么做是从正确（高效）解法得到的，而知道为什么必须得那样做则往往是从错误（低效）的解法当中得到的**
  - 只有在理解了错误的做法为什么错误之后，我们才能深刻地体会到为什么正确的解法是如此正确

### 康托尔、哥德尔、图灵

#### 图灵的停机问题（The Halting Problem）

- 停机问题：不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）
- 反证：

- 假设存在这样的一个程序 `God_algo`

```c
bool God_algo(char* program, char* input) {
  if (<program> halts on <input>)
    return true;
  return false;
}
```

- 由上述算法可以导出一个新的算法：

```c
bool Satan_algo(char* program) {
  if (God_algo(program, program)) {
    while (1);
    return false;
  }
  return true;
}
```

- 当我们把这个算法运用到它自身时 `Satan_algo(Satan_algo);`
  - 如果 `Satan_algo` 能够结束，那么 if 判断成立，即 `God_algo(Satan_algo, Santa_algo)` 返回 `true`，但是最终进入了无穷训话
  - 如果 `Satan_algo` 不能够结束，那么 if 判断失败，但是 `Satan_algo(Satan_algo);` 却返回了 `true`
  - 正如拉普拉斯所说：“陛下，我们不需要（上帝）这个假设”

#### Y Combinator

##### lambda calculus

- lambda 表达式的基本语法（BNF）：
  - `<expr> ::= <identifier>`
  - `<expr> ::= lambda <identifier-list>. <expr>`
  - `<expr> ::= (<expr> <expr>)`

- eg. `\ x y. x + y` （`\` 用来表示 lambda）表示两数相加
  - 使用：`((\ x y. x + y) 2 3)`，把定义的加法函数运用在 2，3 上

- 这个语言系统的简单至极的公理：
  - Alpha 转换公理：比如 `lambda x y. x + y` 可转换为 `lambda a b. a + b`
  - Beta 转换公理：例如 `(lambda x y. x + y) 2 3` 可转换为 `2 + 3`

##### 递归的迷思

- 基于上面两个公理，我们没有办法用 lambda 表示递归函数，但是理想的想法如下：

```
lambda n. IF_Else n==0 1 n*<self>(n-1)
```

- 这里有一个地方没法解决，就是 `<self>` 该填入什么，我们尝试如下：

```
let F = lambda n. IF_Else n==0 1 n*F(n-1)
```

- 可是 `let F` 只是起到一个语法糖的作用，它所代表的 lambda 表达式还没有完全定义出来之前你是不可以使用 `F` 这个名字的
- 继续尝试，将函数自身当作参数传入：

```
let P = lambda self n. IF_Else n==0 1 n*self(n-1)
P(P, 3) // 计算 3 的阶乘，展开为 IF_Else 3==0 1 3*P(P, 3-1)
```

- 但是上面的问题在 `self(n-1)` 这里的函数调用只有一个参数，继续修改：

```
let P = lambda self n. IF_Else n==0 1 n*self(self, n-1)
```

##### 不动点原理

- 前面的函数看上去有些丑陋，我们可以创建一个真正的递归函数，这样 lambda 算子就不需要多余的参数了：

```c
power(n):
  if(n==0) return 1;
  return n*power(n-1);

P(power, 3); // 展开为 IF_Else 3==0 1 3*power(3-1)
```

- `P(power)` 为函数的部分求值（partial evaluation）
- 在 lambda 算子系统里面，如果给一个 lambda 函数的参数不足，则得到的就是一个新的 lambda 函数，这个新的 lambda 函数所接受的参数也就是你尚未给出的那些参数

- 我们对 `P(power)` 套用 beta 公理，可得到 `IF_Else n==0 1 n*power(n-1)`，我们不妨给这个中间函数加上一个帽子

```
lambda n. IF_Else n==0 1 n*power(n-1)
```

- 可以看到上面的式子就是 `power` 本身的定义，因为

```
let power = lambda n. IF_Else n==0 1 n*power(n-1)
P(power) = power
```

- 对于函数 `P` 来说 `power` 是这样一个 “点”：当把 `P` 用到 `power` 身上的时候，得到的结果仍然还是 `power`，也就是说，`power` 这个 “点” 在 `P` 的作用下是不动的

- 对任一伪递归 `F`，必存在一个理想的 `f` 满足 `F(f) = f`。我们假设有一个神奇的函数 `Y`，把它用在任何伪递归函数 `F` 上就能够得到真正的 `f`，也就是说 `Y(F) = f`，也就是

```
Y(F) = f = F(f) = F(Y(F))
```

- 所以 `Y` 具有性质 `Y(F) = F(Y(F))`

- 我们如何实现一个类似 `power` 这样的函数，使得 `power = P(power)`，通过增加一个间接层：

```
let power_gen = lambda self. P(self(self))
```

- 可以通过 `power_gen(power_gen)` 的方式递归调用，展开其实是 `P(power_gen(power_gen))`，把这里的 `power_gen(power_gen)` 替换成 `power`，就是我们要的答案，因而对于给定的 `P`，只要构造出一个相应的 `power_gen`，即 `let power_gen = lambda self. P(self(self))`，然后 `power_gen(power_gen)` 就是我们要找的不动点

##### 铸造 Y Combinator

- 通过上面的推导，我们可以得到：

```javascript
let Y = lambda F. // Y 是一个 lambda 函数，它接受一个伪函数 F
let f_gen = lambda self. F(self(self)) // 在内部生成 f_gen
return f_gen(f_gen) // f_gen 应用到自身，f_gen(f_gen) 就是 F 的不动点（因为 f_gen(f_gen) = F(f_gen(f_gen))），而根据不动点性质，F 的不动点就是那个对应于 F 的真正的递归函数
```

- 我们可以通过展开来看看：

```javascript
let Pwr = lambda self n. If_Else n==0 1 n*self(n-1) // 定义阶乘函数的伪递归版本
Y(Pwr) => let f_gen = lambda self. Pwr(self(self)) return f_gen(f_gen) // 把 Pwr 交给 Y
f_gen(f_gen) => Pwr(f_gen(f_gen)) // 展开可得

// Pwr 需要两个参数，Pwr(f_gen(f_gen)) 中只给出了一个，所以 Pwr(f_gen(f_gen)) 是一个单参函数
Pwr(f_gen(f_gen)) => If_Else n==0 1 n*f_gen(f_gen)(n-1)

// f_gen(f_gen) 又可以展开为 Pwr(f_gen(f_gen))
If_Else n==0 1 n*f_gen(f_gen)(n-1) => If_Else n==0 1 n*Pwr(f_gen(f_gen))(n-1)

// 不妨把 Pwr(f_gen(f_gen)) 替换成 f
f => If_Else n==0 1 n*f(n-1)
```

#### 哥德尔的不完备性定理

- 哥德尔的证明揭示出：任何足够强到蕴含皮亚诺算术系统（PA）的一致（即无矛盾）的系统都是不完备的，所谓不完备，就是说在系统内存在一个为真但无法在系统内推导出的命题
- **说谎者悖论**：例如一个人声称 “我正在说谎” 或者 “我所说的皆为假”，矛盾：
  - 如果他确实在说谎，那么他所说的就是真的，但如果他所说的就是真的，那么他就是在说谎
  - 如果他不在说谎，则他说的话为假，但如果他在说谎，则他说的话就是真的
- 命题 P 说 “P 不可在系统 T 内证明”
  - 假设 T 可以证明出 P，而因为 P 说的就是 P 不可在系统 T 内证明，矛盾产生，说明假设错误
- **排中律**：指在同一个思维过程中，两种思想不能同假，其中必有一真，即 “要么A要么非A”，是形式逻辑的基本规律之一
- 哥德尔构造了这样一个公式：

```
N(n) is unprovable in T
```

- 我们用 `UnPr(X)` 来表达 `X is unprovable in T`，于是上面的公式就变成了 `UnPr(N(n))`，我们把这个公式简记为 `G(n)`
- ...

- 哥德尔的不完备性定理证明了数学是一个未完结的学科，永远有需要我们一人的头脑从系统之外去用我们独有的直觉发现东西
- 哥德尔的不完备性定理最深刻的地方就是它揭示了自指（或自引用，递归调用自身，等等）结构的普遍存在性：`G(n): UnPr( N(n) )`
  - 这里的 `UnPr` 其实是一个形式化的谓词，可以泛化：`G(n): P( N(n) )`
  - 我们算出这个哥德尔公式的自然数编码 g，然后把它扔给 G：`G(g): P( G(g) )`，这就是 Y Combinator 的形式

#### 大道至简 —— 康托尔的天才

- 看上去最复杂的理论其实建立在一个最简单最纯粹的道理之上
- 两个无穷集合 “大小” 一样当且仅当它们的元素之间能够一一对应，比如自然数集合与偶数集合就是一一对应的关系：`f(n)=2n`
- 实数集和自然数集无法构成一一对应，我们可以通过对角线方法证明，假设我们可以把实数集列出来：

```
1 a10.a11a12a13...
2 a20.a21a22a23...
3 a30.a31a32a33...
4 ...
5 ...
```

- 我们构造一个新的实数，它的第 i 位小数不等于 aii
  - 也就是说，它跟上面列出的每一个实数都至少有一个对应的小数位不等
  - 它不等于上面列出的所有实数
  - 这与假设可以列出所有实数相矛盾，所以实数集是不可列的，即不可与自然数一一对应

- 停机问题也可以通过对角线方法得出结论（M1，M2，M3 等是逐一列出的图灵机，上面一行是输入数据，N 表示不停机，数字表示有停机输出）：

```
   1 2 3 4 ...
M1 N 1 N N ...
M2 2 0 N 0 ...
M3 0 1 2 0 ...
M4 N 0 5 N ...
...
```

- 假设存在一个图灵机 H，它能够判断任何程序在任何输入上能否停机，即 `H(Mi,j)` 能够给出 `Mi(j)` 是 N（不停）或数字（停）
- 根据对角线方法，我们可以构造一个图灵机 P，其在 1 上的输出跟 `M1(1)` 不一样，在 2 上面的输出跟 `M2(2)` 不一样。。。总之，P 在 i 上的行为跟 `Mi(i)` 不一样，这样的 P 不难构建：

```
P(i):
if (H(i, i) == 1) then // Mi(i) halts
  return 1 + Mi(i)
else // H(i, i) == 0 (Mi(i) doesn't halts)
  return 0
```

- 因为 P 本身是一个图灵机，但是上面我们已经列出了所有的图灵机，所以必然存在一个 k，使得 Mk = P
  - 两个图灵机相等当且仅当它们对于所有的输入都相等，也就是：

  ```
  Mk(k) = P(k) = 
    1+Mk(k) if Mk(k) halts
    0 if Mk(k) doesn't halt
  ```

  - 上面的式子矛盾，因此不存在这样的图灵机

#### 罗素悖论

- 罗素悖论用数学的形式来描述就是：`R = {X: X 不属于 X}`
  - 当初康托尔在思考无穷集合的时候发现可以称 “一切集合的集合”，这样一个集合由于它本身也是一个集合，所以它就属于它自身
  - 如果 R 属于 R，根据 R 的定义，R 就不应该属于 R
  - 如果 R 不属于 R，则再次根据 R 的定义，R 就应该属于 R
- 罗素悖论也可以使用对角线方法证明

### 数学之美番外篇：快排为什么那样快

- 猜数字游戏：二分法最优 —— 答案的任何一个分支都是等概率的
- 称球游戏：12 个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重
  - 12 个小球两两配对上天平称，有 24 种情况需要称量
  - 天平的输出有 3 种结果：平衡、左倾、右倾
  - 这相当于我们的问题有 3 个答案，可以将所有的可能性切成三份
  - 一次称量就可以将答案的可能性缩减为原来的 1/3，三次就能缩减为 1/27，理论上是完全可以三次称出来的
  - 然后我们可以思考如何称，比如 6、6 称，3、3 称，或者是 2、2 称，最后发现 2、2 称可以把可能性缩减为原来的 1/3
  - 这里的核心思想就是选择一种称法，使得 3 种结果的概率是均等的

![](/assets/asj/ball_game_decision_branch.png)

- 用上述看问题的视角看排序，排序的本质是：一组未排序的 `N` 个数字，它们一共有 `N!` 种重排，其中只有一种排列是满足题意的
- 基于比较的排序的基本操作单元都是 “比较 a 和 b”，这个问题的答案只有 “是” 或 “否”
  - 一个只有两种输出的问题最多只能将可能性空间切成两半
  - 那么 `N` 个元素的 `N!` 种可能排列只需要 `log2(N!)` 近似于 `NlogN`

- 将排序问题看成和猜数字一样，是通过问问题来缩小/排除（narrow down）结果的可能性区间
  - “最好的问题” 就是那些能够均分所有可能性的问题，因为那样的话不管问题的答案如何，都能排除掉 `(k-1)/k`（`k` 为问题的答案有多少种输出，猜数字是 2，称球是 3）

### 数学之美番外篇：平凡而又神奇的贝叶斯方法

- 逆概问题，例子
  - 正向概率：假设袋子里面有 N 个白球，M 个黑球，你伸手进去摸一把，摸出黑球的概率是多大？
  - 反向概率（逆概）：如果我们事先不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测？

- 我们需要做两件事：
  1. 算出各种不同猜测的可能性大小（后验概率）
  2. 算出最靠谱的猜测是什么（模型比较）

- 贝叶斯的一般形式的表达式：

```
P(B|A) = P(A|B) * P(B) / (P(A|B) * P(B) + P(A|~B) * P(~B))
P(B|A) = P(AB) / P(A)
P(B|A) * P(A) = P(AB)
```

- 拼写检查/纠正器，我们看到一个用户输入了一个不在字典中的单词，我们需要去猜测他究竟输入的是什么：

```
我们需要求：
P(我们猜测他想输入的单词|他实际输入的单词)，以及使得这个概率最大的单词

我们可以将我们的多个猜测记为 h1，h2 ...，它们都有一个有限且离散的猜测空间 H（单词的数量是有限的）
将用户实际输入的单词记为 D，所以有 P(h1|D)，P(h2|D) ...，可以统一记为 P(h|D)

运用贝叶斯公式可得：
P(h|D) = P(h) * P(D|h) / P(D)

因为对于所有猜测的 h1，h2，... P(D) 都是一样的，所以（在比较的时候）可以忽略这个常数
我们只需要知道 P(h|D) 正比于 P(h) * P(D|h)

这里的 P(h) 为 “这个猜测本身独立的可能性大小（先验概率，Prior）” —— h 本身在词汇表中被使用的可能性（频繁程度）大小
这里的 P(D|h) 为 “这个猜测生成我们观测到的数据的可能性大小（似然，Likelihood）” —— 想输入 h 却输入成 D 的大小

剩下的事情就是把所有的概率计算出来，选出最大的就好

```

- 观测数据总是会有各种各样的误差，过分去追求完美解释会落入所谓的数据过配（overfitting）的境地
  - `P(D|h)` 大不代表你的 h（猜测）就是更好的 h，还要看 `P(h)` 是怎样的
  - **奥卡姆剃刀精神**：如果两个理论具有相似的解释力度，优先选择那个更简单（平凡、常见）的
  - 一个现实的模型往往只提取出几个与结果相关度很高，很重要的因素（cause）

- 奥卡姆剃刀就是说 `P(h)` 较大的模型有较大的优势，而最大似然则是说最符合观测数据的（即 `P(D|h)` 最大的）最有优势，整个模型的比较就是这两方面的拉锯
- 先验概率里面的 “先验” 并不是指先于一切经验，而是仅指先于我们 “当前” 给出的观测数据（最大似然）而已（eg. 抛硬币）

- 例子：树后面有多少个箱子？

![](/assets/asj/how_many_box_behind_tree.png)

- 两种可能的解释：

![](/assets/asj/how_many_box_behind_tree_2.png)

- 我们会觉得第二种不太可能，用概率论的语言来说就是，猜测 h 不成立，因为 `P(D|h)` 太小

- 自然语言二义性：
  - The girl saw the boy with a telescope
    - 如果是 The girl saw the-boy-with-a-telescope，我们会觉得男孩手里拿个东西，这个东西偏偏还是望远镜，小概率事件
    - 而如果是 The girl saw with-a-telescope the boy 的话，行为和描述就完全解释的通了
  - 参见《Psychology of Judgment and Decision Making》及《Rationality for Mortals》第 12 章
    - 是两本书的第 12 章还是仅仅是后一本的，明显后者的可能性更高

- 贝叶斯奥卡姆剃刀（Bayesian Occam's Razor）：这个剃刀工作在贝叶斯公式的似然（`P(D|h)`）上，而不是模型本身（`P(h)`）的先验概率上

- 贝叶斯的应用：
  - **中文分词**：令 X 为字串（句子），Y 为词串（一种特定的分词假设）。我们需要寻找使得 `P(Y|X)` 最大的 Y，即 `P(Y|X) <- P(Y) * P(X|Y)`，也就是 “这种分词方式（词串）的可能性” 乘以 “这个词串生成我们的句子的可能性”
  - **统计机器翻译**：给定一个句子 e，它的可能的外文翻译 f 中哪个是最靠谱的，即我们需要计算 `P(f|e)`，也就是 `P(f|e) <- p(f) * P(e|f)`
  - **贝叶斯图像识别（Analysis by Synthesis）**：首先是视觉系统提取图形的边角特征，然后使用这些特征自底向上地激活高层的抽象概念，然后使用一个自顶向下的验证来比较到底哪个概念最佳地解释了观察到的图像
  - **EM 算法与基于模型的聚类**
  - **最大似然与最小二乘**

- 越是往表层去，世界就越是繁复多变。从机器学习的角度来说，特征（feature）就越多，成百上千维度都是可能的，特征一多，数据就不够用

## 层级贝叶斯模型

![](/assets/asj/layer_beyes_model.png)

- 普通的贝叶斯都是在同一个事物层次上的各个因素之间进行统计推理，而层级贝叶斯会将这些因素背后的因素（原因的原因，原因的原因的原因）囊括进来
- 隐马可夫模型（HMM）就是一个简单的层级贝叶斯模型：

![](/assets/asj/hmm.png)