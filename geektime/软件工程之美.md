# 项目规划篇

## 可行性分析

- 如果发现方案不具备可行性，也应及时调整方案或停止项目以止损
- 从三个方面来做可行性分析：
  - **经济可行性**：从成本和收益角度分析，看投入产出比，不仅要分析短期利益，还要分析长期利益
  - **技术可行性**：技术上是否可行，如果有技术上解决不了的问题又能否规避，关键在人
  - **社会可行性**：社会可行性涉及法律、道德、社会影响等社会因素
- 哪怕你做的可行性研究不能改变决策，最后项目结束的时候，和当初做的可行性研究做一下对比，也都是非常宝贵的项目经验积累
- 如果可行性研究并不能给你一个很明确的结果，也可以考虑小范围试点，先实现一个最小化可行产品，等验证了可行性，再逐步加大投入

## 技术转项目管理

- 项目管理通常是技术人员转型管理的第一步
- 想要技术转型管理，首先从转变思维方式开始，从技术思维到管理思维，从关注细节到关注整体
- 就软件项目管理来说，“道” 就是管好人、管好事
  - 怎样管好软件项目中的人？
    - 管理好客户的预期
    - 用流程和规范让项目成员一起紧密协作
  - 怎样管好软件项目中的事？（对项目中事情的管理，本质上就是对软件开发过程的管理）
    - 选择适合项目的开发模式（瀑布模式或敏捷开发）
    - 制定好项目计划
    - 对计划进行跟踪和控制，同时做好风险管理

    ![](/assets/geektime/software_project_management.png)

- 技术转管理的一些经验教训
  - 控制你想写代码的冲动（技术人员转型管理的最大障碍是什么，那就是过于关注技术，而忽略了其他事情）
  - 团队的成功，才是你的成功（并不是你把上级的工作做了就能升职，而是你的下级都成长了，能替代你的位置了，你就可以升职了）
  - 形成自己的管理风格（完全可以根据自己的特点，找到适合自己的管理风格）
  - 坚持就是胜利

## 项目计划

- 参与做计划的过程，可以让你对项目的各种事情了然于胸，这就相当于扩大了你的上下文，让你有更高的视角看待当前工作遇到的问题
  - 试着做计划就是一个非常好的培养大局观的方式
  - 你在制定计划的过程中，需要去综合考虑各种因素：有哪些任务要做，可能存在什么风险，任务之间的依赖关系是什么，等等
- 制定项目计划的三个基本步骤
  1. 任务分解
    - WBS（Work Breakdown Structure）就是把要做的事情，按照一个树形结构去组织，逐级分解，分割成小而具体的可交付结果，直到不能再拆分为止
    - 在制定计划时，除了要拆分任务，还需要反复思考各种可能存在的问题
  2. 估算时间
    - 任务拆分的越细致，想的越清楚，就能估算的越准确
    - 要让负责这个任务的人员参与估算
    - 提问可以帮助双方搞清楚真实的情况是什么样的，而且也不会招致反感
    - 对于估算的结果，通常还要考虑增加一些余量，因为实际项目执行过程中，有可能会有突发状况
  3. 排任务路径
    - 排路径就是要根据任务之间的关系，资源的占用情况，排出合适的顺序
- 对于周期很长的项目，可以设置里程碑。一来可以通过 DDL 来推动进度，二来对成员也有比较好的激励
- 项目管理中，并不是计划制定好了就完事了，还需要跟踪和调整，敏捷开发的两个实践：
  - 每日站立会议
  - 看板

## 流程和规范

- 好的项目管理，不需要直接管人管事，而是管理好计划和流程规范；项目成员不需要按照项目经理的指令做事，而是遵循计划和流程规范
- 制定流程规范的四个步骤：
  1. 明确要解决的问题
  2. 提出解决方案
  3. 达成共识，推广执行
  4. 持续优化，不断改进
- 应该尽可能借助技术手段来推动甚至替代流程规范
  - IDE 中的代码检查工具
  - CI/CD
  - git

## 开会

- 会议是不是有效率，取决于它创造的价值是不是高于其成本
  - 比如说有的会议，花的成本不是组织者的，对他来说，得到他的会议价值就可以了
- 跟软件项目金三角的理论一样，只要从两个角度去想办法：减少开会的成本，增加开会创造的价值
- 减少开会成本的方法：
  - 砍掉一些没有价值的会议
    - 没有目标
    - 不能形成决策，没有会后行动
    - 你属于可有可无的角色
    - 可以通过创建文档来避免的会议
  - 减少参与会议的人
  - 缩短开会时间
  - 提升会议所创造的价值
    - 每个会议要有明确的目的和主题，所有的讨论都要围绕会议目的展开
    - 还有开会后，要有明确的结论，有后续的待办事项，落实到个人，对待办事项有跟踪
    - 没什么价值的会议，又必须要参加的会议，可以在会前找些需要解决的难题，然后在会上思考，这样可以避免时间的浪费

## 项目管理工具

- 一个任务，只有 0% 和 100% 两种状态是准确的，中间状态都是不靠谱的
- 项目管理工具的演变
  - 最初的项目管理软件：MS Project
  - 基于 Ticket 的任务跟踪系统
  - 基于看板的可视化任务管理

## 风险管理

- 风险管理就是指在项目进行过程中，识别可能的风险，对风险进行评估，并加以监控，从而减少风险对项目的负面影响
- 风险包含两个方面
  1. 发生后，会造成什么样的损失
  2. 发生的概率有多大
- 如何做好风险管理
  1. 培养风险意识
    - 项目中的任务，不能盲目乐观，都思考一下它最坏的结果是什么，如果最坏的结果不能接受，就说明要有个 B 计划，考虑风险管理了
  2. 管理风险
    - 风险识别，识别可能的风险
    - 风险量化，对风险进行评估量化（基于损失和概率）
    - 应对计划，对风险制定应对策略
      ![](/assets/geektime/risk_types.png)
      - 回避风险——更改导致风险的方案，eg 用熟练的技术替代不熟练的技术
      - 转移风险——将损失转嫁出去，eg 购买云服务
      - 缓解风险——降低风险发生概率或减少可能造成的损失，eg 数据库定期备份
    - 风险监控，对风险进行监控预警
      - 对监控的内容量化
      - 设置阈值
      - 后续的报警和处理机制

## 项目文档

- 先写文档，就会抛开代码细节，去站在全局思考
- 文档写作，关键是通过文档把你的想法表达出来，至于用词、格式相对都是其次的
- 具体可行的文档写作方法：
  - 从模仿开始，参照一些成熟的模版来写
  - 从小文档开始
    - 别人给你讲一个问题的时候记录下来
    - 你给别人讲一个问题的时候记录下来
    - 解决一个技术难题时记录下来方案
  - 从粗到细，迭代更新
    - 脑图 -> PPT -> 收集反馈 -> 文档
  - 基本的画图技巧
    - 线框图
    - 流程图
    - 时序图
    - 各种格式截图

# 需求分析篇

## 需求分析

- 用户需求是由用户提出来的，期望满足自身一定需要的要求
- 产品需求就是在分析提炼用户真实需求后，提出的符合产品定位的解决方案
- 需求分析，就是对用户需求进行提炼分析，最终形成产品需求的过程
- 针对每个用户需求的需求分析过程，需要经过三个步骤：
  1. 挖掘真实需求
    - 大部分用户提的需求，都不见得是其真实的需求，需要透过现象看本质，去挖掘其背后真实的需求
    - 从**目标用户**、**使用场景** 和 **想要解决的问题** 三个角度入手
  2. 提出解决方案
  3. 筛选和验证方案

- 软件项目的用户需求

![](/assets/geektime/requirement_analysis.png)

- 收集需求
  - 潜在的方法：
    - 头脑风暴
    - 用户调研
    - 竞品分析
    - 快速原型
- 分析需求
  - 表层需求
  - 深层需求
  - 底层需求
- 需求评估
  - 以决定做还是不做，优先级如何，先做哪些再做哪些
  - 考虑因素：
    - 可行性
    - 成本
    - 商业风险和收益
    - 紧急性与重要性
- 需求设计
  - 可以用草图、原型设计工具、界面设计工具进行设计
  - 可以参考其他成熟的产品
- 验证需求
  - A/B 测试

## 原型设计

- 第一阶段确认界面布局和内容，第二阶段确认交互，第三阶段实现
- 可以将每次原型设计过程分成四个部分：分析、设计、实施和验证
  1. 分析
    - 需求分析
  2. 设计
    - 画产品的信息结构图，eg

    ![](/assets/geektime/geektime_info_structure_graph.png)

    - 画产品使用流程图，eg

    ![](/assets/geektime/geektime_user_flow_graph.png)
  3. 实施
    - 对每个界面画流程图
    - 要优先考虑满足产品需求，然后是让界面好看好用
  4. 验证
    - 一般在正式的项目中，针对原型设计，需要有相应的评审会议，让大家提出反馈，根据反馈再作出调整
- 原型设计工具的选择
  - 面向的平台：Web、桌面、手机
  - 保真度：中等保真度还是高保真度
  - 功能：是否满足你的要求
  - 成本：价钱是否可以接受

## 产品意识

- 程序员的价值
  1. 你的价值体现在你所做的产品上
  2. 你的价值体现在团队中的稀缺性
- 产品意识，本质就是一种思维方式，一种站在产品角度思考问题的方式
  - 商业意识
    - 所做的产品的商业价值
    - 商业意识的另一方面其实是成本——成本意识
  - 用户意识
    - 做产品时，你要能挖掘出用户的真实需求，让产品有好的用户体验，这需要你要有同理心，能站在用户的角度去思考和体验产品
    - 多一点用户意识，想到的问题将会多了很多维度，比如说：
      - 能让自己的负责的模块有更好的体验
      - 让自己的技术方案更好地满足用户需求，用户更满意
      - 让自己设计的接口、API 更好用，与同事愉快合作
  - 数据意识
    - 在产品设计、产品运营时，通过数据来发现问题、证实结果
- 如何培养产品意识
  - 解放思想，改变习惯，多实践
  - 技术思维会关注用什么技术，关注技术细节，关注功能 “如何” 实现；产品思维会关注用户体验，关注一个功能所创造的价值，会去思考为什么要或者不要一个功能，eg

  ![](/assets/geektime/product_mindset_eg.png)

  - 改变习惯是是指在日常使用产品、开发产品的时候，多站在产品的角度思考，去思考它的商业价值、用户体验、使用场景等等
  - 自己开发的功能模块完成后，可以把自己当成用户试试，如果觉得体验不好或者有更好的建议，都可以反馈给产品经理
  - 其实不用担心没有什么好的想法，可以从日常生活中，自己的需求、家人和朋友的需求中，去找到合适的产品需求

## 如何应对需求变更问题

- 两个常见的解决方案：
  - 增强需求变更流程，让需求变更规范起来
  - 快速迭代，缩短版本周期
- 像软件工程这样偏理论知识的学习，一定不要停留在解决方案上，要追本溯源，研究问题背后的原因，研究理论背后的来龙去脉
- 需求变更的原因：
  - 需求的确定性
    - 软件工程的需求是抽象的、模糊、不精确的，只有在开发有了雏形后，才会清楚真正的需求
  - 需求变更的成本
- 解决办法
  - 提升需求确定性，把需求分析做好，减少需求变更
  - 提高需求变更的成本，让客户或者产品经理不能太容易就变更需求
  - 降低响应需求变更的成本，可以方便快捷地响应需求变更

# 系统设计篇

## 架构设计

- 复杂的软件项目，通常有两个特点
  - 需求不确定
  - 技术复杂
- 技术的复杂性通常体现在四个方面：
  - 需求让技术变复杂
  - 人员会让技术变复杂
  - 技术本身也是复杂的
  - 要让软件稳定运行是复杂的
- 架构设计可以很好地解决技术复杂的问题：
  - 架构设计可以降低满足需求和需求变化的开发成本
  - 架构设计可以帮助组织人员一起高效协作
  - 架构设计可以帮助组织好各种技术
  - 架构设计可以保障服务稳定运行
- 架构设计的 **目标**，是用最小的人力成本来满足需求的开发和响应需求的变化，用最小的运行成本来保障软件的运行
- 架构设计的 **道**，就是组织人员和技术把系统和团队拆分，并安排好切分后的排列关系，让拆分后的部分能通过约定好的协议相互通信，共同实现最终的结果
- 如何做好架构设计
  1. 需求分析
    - 一个常用的分析方法就是分析用例，也就是了解主要用户角色和其使用的场景
  2. 选择相似的成熟的架构设计方案
  3. 自顶向下层层细化
    - 部署架构
    - 分层和分模块
      ![](/assets/geektime/geektime_arch_layer_graph.png)
    - API 设计、数据库设计、模块的设计
  4. 验证和优化架构设计方案

## 技术选型

- 技术选型看起来是个技术的选择，但其实是一个和项目情况密切相关的项目决策
- 项目决策中常见的坑：
  - 把听到的观点当事实
    - 在做决策之前，至少需要验证一下
  - 先入为主，有了结论再找证据
- 如何做好技术选型：
  - 问题定义
    - 为什么需要技术选型？技术选型的目标是什么？
    - 只有明确了技术选型的目标，才能有一个标准可以来评判该选择哪一个方案
  - 调研
    - 满足技术选型目标吗？
    - 满足范围、时间和成本的约束吗？
    - 是不是可行？
    - 有什么样的风险？风险是不是可控？
    - 优缺点是什么？
  - 验证
    - 可以通过一个小型的快速原型项目，用候选的技术方案快速做一个原型出来
  - 决策
    - 在调研和验证完成后，可以召集所有利益相关人一起，就选择的方案有一个调研结果评审的会议，让大家提出自己的意见，做出最终的决策
- 技术选型，也不要太过于纠结，要勇于决策，选定了就坚定的去执行
- Make It Work -> Make It Right -> Make It Fast

## 架构师

- 对于程序员来说，并不代表一定要有一个架构师的头衔，而是心中有大局观，有架构师的思维，从而能理解架构设计，能写出好的程序
- 对于架构师来说，要控制技术复杂性，有几种有效的方式：**抽象、分治、复用和迭代**
- 抽象思维
  - 在软件项目中，遇到类似的场景，就会考虑抽象出来，总结一个规则和方法
  - 在架构设计中，对需求进行抽象建模后，可以帮助我们隐藏很多无关紧要的细节
- 分治思维
  - 对复杂系统分而治之，分解成小的、简单的部分
- 复用思维
  - 通过对相同内容的抽象，让其能复用于不同的场景
- 迭代思维
  - 好的架构设计，通常不是一步到位，而是先满足好当前业务需求，然后随着业务的变化而逐步演进
- 一个好的架构师，不仅技术要好，还要懂业务；能从整体设计架构，也能在局部实现功能
- 要成为好的架构师，需要具备几个条件：
  - 有架构师思维：具备良好的抽象思维、分治思维、复用思维和迭代思维
  - 懂业务需求：能很好地理解业务需求，能针对业务特点设计好的架构
  - 有丰富的编码经验：像抽象、分治、复用这些能力，都需要大量的编码练习才能掌握，另外保持一定量的编码经验也有助于验证架构设计
  - 良好的沟通能力：架构师需要沟通确认需求，需要让团队理解架构设计
- 如何成为一个好的架构师：
  - 要成为一个优秀的程序员
  - 多模仿，多学习
  - 选择好行业和平台

## 技术债务

- 债务的 “利息”，就是在后面对软件做修改的时候，需要额外的时间成本
- 技术债务不一定都是坏的，比如
  - 快速原型开发模型
  - 提升短期的开发速度，让软件能尽快推出
- 对于项目中的债务，我们要清楚的知道有哪些技术债务，以及它给项目带来的收益和产生利息，这样才能帮助我们管理好这些债务
- 技术债务产生的原因
  - 轻率（reckless）还是谨慎（prudent）
  - 有意（deliberate）还是无意（inadvertent）

![](/assets/geektime/technical_debt.png)

- 识别技术债务
  - 开发速度降低
  - 单元测试代码覆盖率低
  - 代码规范检查的错误率高
  - Bug 数量越来越多

- 处理技术债务的策略
  - 重写：推翻重来，一次还清
  - 维持：修修补补，只还利息
  - 重构：新旧交替，分期付款

- 通常，如果你纠结于不知道该选择哪一种策略时，那就选择重构的策略，因为这是相对最稳妥有效的

- 实施策略
  - 对于重写的策略，要当作一个正式的项目来立项，按照项目流程推进
  - 对于重构的策略，要把整个重构任务拆分成一个个小任务，放到项目计划中，创建成 Ticket，放到任务跟踪系统中跟踪起来
  - 对于维持的策略，也要把需要做的修补工作作为任务，放到计划中，放到任务跟踪系统中

- 实施策略的关键就在于要落实成开发任务，作为项目计划的一部分

- 预防才是最好的方法
  - 预先投资：弄好架构设计、写好代码
  - 不走捷径：做好代码审查、保障单元测试代码覆盖率
  - 及时还债：把欠下的债务记下，放到任务跟踪系统中，安排在后续的开发任务中

# 开发编码篇

## 提高开发效率的方法

- 积极主动
  - **想想再回应**（在回应之前，给自己一点时间想想，站在积极的方面理性思考一下，控制本能反应）
  - **减少关注圈，扩大影响圈**
    - 要区分哪些事，是我可以影响和掌控的，这些事则是 “影响圈”
    - 不要总盯着自己无法改变的部分，你需要要多花时间精力在影响圈上
    - 接受不能改变的，改变能改变的，尽量扩大可改变项的范围
- 以终为始
  - **经常停下来想想目标**
    - 我的原始目标是什么？我正在做的事是我的目标吗？如果不是，那么马上回到自己的原始目标去
  - **制定原则**，比如：
    - 增加一个功能，就要写自动化测试，如果来不及写，就给自己写一条 Ticket
    - 先运行再优化 (Make it Work Make It Right Make It Fast)
    - 不复制粘贴代码 (Don’t repeat yourself)
    - 每个 Pull Request 要尽可能小
  - **公开自己的计划**
    - 有了计划指引和时间点的压力，会倒逼着自己时刻专注于目标是什么
- 要事第一
  - 重要紧急的事情马上处理
  - 重要不紧急的要事，要花最多的时间在上面
  - 紧急不重要的事凑一起集中做
  - 不重要不紧急的事情能不做就不做

## 持续交付

- 持续交付如果细分，其实可以分成持续集成、持续交付和持续部署三个概念
- 集成
  - 集成指的是每个人把自己开发的分支代码，合并到主干上，以便测试打包
  - 传统的集成，都是在开发阶段整体完成的差不多了，才开始集成，而持续集成的做法，则是每次有代码合并入主干之前，都进行集成，持续的集成
  - 代码集成到主干之前，必须通过自动化测试，只要有一个测试用例失败，就不能集成

  ![](/assets/geektime/continuous_integration.png)

  - 持续集成的好处：
    - 配合自动化测试，这样可以保证主干的代码是稳定的
    - 频繁集成可以让开发人员总能从主干及时获得最新的代码，不至于像类库、API 不一致等问题到最后测试的阶段才暴露出来
  - 持续集成主要的问题就是搭建整个持续集成环境，要稍微麻烦一点，另外需要配合一些流程规范来辅助执行
- 交付
  - 交付则指的是软件产品在测试验收通过后，具备发布到生产环境交付给客户使用的条件
  - 持续交付，就是在持续集成的基础上，再进一步，在功能合并到主干后，不仅会进行自动化测试，还会打包，并部署到测试环境中

  ![](/assets/geektime/continuous_delivery.png)

  - 把持续交付的工作做好后，部署生产环境会变得非常简单，只需要点一下按钮或者运行一个命令，就可以很快完成
  - 持续交付，对于生产环境的部署，依然需要有手动确认的环节
- 部署
  - 部署指的是将代码发布到各种环境，比如部署测试环境以供测试
  - 从手动部署到脚本自动化部署
    - 自动化逐步应用到运维领域，确实是让部署过程更容易，但也只是让部署过程更容易，还是无法解决发布版本的质量问题
  - 持续部署，和持续交付唯一的不同，就是手动确认的环节都没有了，每次代码从分支合并到主干，在自动化测试通过后，会直接自动部署生产环境，不需要人工确认

- 好处：
  - 持续交付并不能消除 Bug，而是让它们非常容易发现和改正
  - 持续交付让开发过程中从代码合并，一直到最终部署，都实现了自动化，能极大程度上提高效率
  - 每次合并之前都需要通过自动化测试，因此错误会少很多
  - 在最初搭建持续交付环境的时候，是要投入一定成本的，但是从长远看，开发效率提升了，代码质量提高了，反而是对降低项目的整体成本有帮助的

- 如何搭建持续交付环境
  - 持续集成
    - 需要有源代码管理工具——Git
    - 需要写自动化测试代码
  - 持续交付
    - 对代码构建的过程可以反复进行，并且每次构建的结果是一致的、稳定的
    - 所有环境的配置都存在于源代码管理工具中，不仅仅是代码
    - 需要自动创建针对于不同环境的发布包
    - 所有环境的部署发布步骤都必须是自动化的
  - 持续集成工具
    - Jenkins
    - Go CD
    - Travis CI
    - GitLab CI
    - Azure Pipelines

## 软件工程师的核心竞争力

- 学习能力、解决问题能力和影响力构成了软件工程师的核心竞争力
  - 最底层、最基础的就是学习能力，通过学习能力，快速学习掌握新技术
  - 中间一层就是解决问题的能力，充分利用学到的技术，去发现问题、分析问题和解决问题
  - 最上一层就是影响力，是核心竞争力的综合体现

![](/assets/geektime/software_engineer_pyramid.png)

- 如何构建自己的知识体系
  - 首先需要在一个技术领域深耕
    - 只有一个领域的知识你真正吃透，才能有效地共享到其他领域，构成一个知识领域的森林
  - 往相近的领域逐步横向拓展
- 如何提高解决问题的能力
  - 解决问题的一套方法论：
    1. 明确问题
      - 搞清楚目标是什么，才能做到有的放矢
    2. 拆分和定位问题
      - 一个复杂的问题，只有经过拆分，才好找到本质的问题
    3. 提出解决方案并总结
      - 发现并分析完问题后，找到解决方案是容易的，但很有必要总结一下，总结两点：
        - 下次有这种问题怎么解决，是不是可以做的更好？
        - 这种问题是不是可以预防？如果可以，应该怎么做？
- 如何提升影响力
  - 在某个领域做出了足够牛的成绩
  - 做事情超出预期
  - 帮助其他人就是在帮助自己
  - 分享就是学习和打造影响力

## 自动化测试

- Google 将自动化测试分成了三大类：小型测试、中型测试和大型测试，eg.

![](/assets/geektime/auto_testing_example.png)

- 小型测试
  - 小型测试是为了验证一个代码单元的功能，例如针对一个函数或者一个类的测试，比如单元测试
  - 小型测试的运行，不需要依赖外部
  - 如果有外部服务（比如文件操作、网络服务、数据库等），必须使用一个模拟的外部服务
- 中型测试
  - 中型测试是验证两个或多个模块应用之间的交互，通常也叫集成测试
  - 对于中型测试，可以使用外部服务（比如文件操作、网络服务、数据库等），可以模拟也可以使用真实的服务
  - 至于中型测试要不要使用模拟的服务，有个简单的标准，就是看能不能在单机情况下完成集成测试，如果可以就不需要模拟，如果不能，则要模拟避免外部依赖
- 大型测试
  - 大型测试则是从较高的层次运行，把系统作为一个整体验证，大型测试也叫系统测试或者端对端测试
  - 对于大型测试，通常会直接使用外部服务（比如文件操作、网络服务、数据库等），而不会去模拟
- 契约测试
  - 让微服务在测试时，不需要依赖于引用的外部的微服务，在本地就可以模拟运行，同时又可以保证外部微服务的接口更新时，本地模拟的接口（契约）也能同步更新
  - 中型测试的一种了，因为它不需要依赖外部服务，本机就可以完成测试

- 不同测试的区分

![](/assets/geektime/test_categories.png)

- 越是小型测试，执行速度越快，越是大型测试，执行速度越慢
- 另外越是大型测试，写起来的成本也相应的会更高，所以一般项目中，小型测试最多，中型测试次之，大型测试最少
- 测试代码的四部分：
  - 准备
  - 执行
  - 断言
  - 清理
- 一个完整的自动化测试要包括三个部分的测试
  - 验证功能是不是正确：例如说输入正确的用户名和密码，要能正常注册账号
  - 覆盖边界条件： 比如说如果用户名或密码为空，应该不允许注册成功
  - 异常和错误处理：比如说使用一个已经用过的用户名，应该提示用户名被使用
- 让自动化测试在持续集成上运行非常重要，只有这样才能最大化地发挥自动化测试的作用

![](/assets/geektime/test_in_cicd_env.png)

## 源代码管理工具

- 如何用好源代码管理工具
  1. 要频繁的提交
    - 便于 Code Review
    - 如果出现问题，也可以迅速定位或者直接回滚
    - 让团队成员可以及时同步最新代码，不至于在最后合并时，产生有大量的合并冲突
  2. 每次提交后要跑自动化测试
    - 对问题进行甄别和修复，确保提交的代码质量是没问题的
  3. 提交的代码要有人审查
- Github 开发流程的几个常见问题
  - **怎么发布版本？**
    - 从 master 上创建一个 Tag，例如 v1.0，然后将 Tag v1.0 上的内容部署到生产环境
  - **怎么给线上版本打补丁？**
    1. 基于之前的 Tag 创建一个分支（例如 hotfix-v1.0-xxx）出去
    2. 在分支上修复，然后提交 PR，代码审查和自动化测试通过后，从分支上创建一个新的 Tag （例如 v1.0.1）
    3. 将新的 Tag 发布部署到生产环境
    4. 最后再把修改合并回 master
  - **如果我经常需要打补丁，有没有比 Tag 更好的办法？**
    1. 每次发布后，可以创建一个发布版本的分支，例如 release-v1.0
    2. 每次打补丁，都直接从发布分支 release-v1.0 而不是 master 创建新的分支（例如 hotfix-release-v1.0-xxx）
    3. 修复后提交 PR，代码审查和自动化测试通过后，合并回分支 release-v1.0
    4. 然后基于 release-v1.0 分支发布补丁

- 无论你基于哪一种开发流程，最好能做到这两点
  - 有一个稳定的代码分支
  - 在合并分支之前，对代码有审查，自动化测试要能通过

# 软件测试篇

## 软件测试与产品质量

- 功能质量、代码质量和过程质量这三个方面组合在一起，很好地概括了软件质量
- 软件质量的首要负责人是项目负责人，其次是开发人员，然后才是软件测试
- 但人人为质量负责，很容易变成一句口号而很难落实。就像三个和尚没水喝的故事里面那样，当质量变成每个人的责任时，就没有人真正为质量负责了
- 要做到 “人人为产品质量负责”，要落到行动而不是口号上，组织上扁平化、小型化，分工上打破岗位墙，制度上鼓励大家重视质量，才能真正建立重视产品质量的文化，一起把产品的质量提升上去

- 如果对软件测试的工作简单总结一下，就是发现 Bug，报告 Bug，跟踪 Bug
- 开发人员的重点是放在如何实现上，而测试人员的重点是在检测
- 尽可能多的测试覆盖的方法：
  1. **等价类划分**
    - 如果一类数据对于发现 Bug 的效果是一样的，那么这类数据就是一个等价类，测试的时候只要从里面任意选取一个值就好了
  2. **边界值分析**
    - 对等价类的补充，因为输入输出的边界是非常容易出错的一个地方
  3. **探索性测试**
    - 探索性测试就是根据前面的测试结果，通过有效的策略进行测试
- 回归测试是指修改了旧代码后重新进行测试，以确认修改没有引入新的错误或导致其他代码产生错误

## 测试工具